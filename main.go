package main

import (
	"encoding/gob"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"time"

	"github.com/danilopolani/gocialite"
	"github.com/gorilla/mux"
	"github.com/gorilla/sessions"

	"github.com/joho/godotenv"
)

const (
	// DefaultPort to start up server
	DefaultPort = "9000"
)

// User holds a users account information
type SSOUser struct {
	Username      string
	Authenticated bool
}

// store will hold all session data
var store *sessions.CookieStore

var gocial = gocialite.NewDispatcher()

type spaHandler struct {
	staticPath string
	indexPath  string
}

var clientID, clientSecret string

func init() {

	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}
	clientID = os.Getenv("OAUTH_CLIENT_ID")
	clientSecret = os.Getenv("OAUTH_CLIENT_SECRET")

	/*
	 * Option 1 use preset cookie store
	 * FIXME: Should come from os.getenv()
	 */
	store = sessions.NewCookieStore([]byte("super-secret-key-for-session-store"))

	/*
	 * Option 2 use autogenerated cookie store
	 * CONS:
	 * After ever reboot, the old cookie store is inaccessible due to random BUT might be a good thing
	 */
	// authKeyOne := securecookie.GenerateRandomKey(64)
	// encryptionKeyOne := securecookie.GenerateRandomKey(32)
	// store = sessions.NewCookieStore(
	// 	authKeyOne,
	// 	encryptionKeyOne,
	// )

	// Set http session for 30mins
	// FIXME: Should come from os.getenv()
	store.Options = &sessions.Options{
		MaxAge:   60 * 30,
		HttpOnly: true,
	}

	gob.Register(SSOUser{})
}

func main() {
	var port string
	if port = os.Getenv("PORT"); len(port) == 0 {
		fmt.Printf("Warning, PORT not set. Defaulting to %v\n", DefaultPort)
		port = DefaultPort
	}

	router := mux.NewRouter()

	router.HandleFunc("/auth", authRedirectHandler)
	router.HandleFunc("/auth/callback", authCallBackHandler)
	router.HandleFunc("/auth/validate", authValidateHandler)

	router.HandleFunc("/api/health", func(w http.ResponseWriter, r *http.Request) {
		// an example API handler
		json.NewEncoder(w).Encode(map[string]bool{"ok": true})
	})

	spa := spaHandler{staticPath: "static", indexPath: "index.html"}
	router.PathPrefix("/").Handler(spa)

	// Unsure if headers needed on CLOUD PaaS
	// headersOk := handlers.AllowedHeaders([]string{"Accept, Authorization, Content-Type, Content-Length, Accept-Encoding, X-Requested-With"})
	// originsOk := handlers.AllowedOrigins([]string{"*"})
	// originsOk := handlers.AllowedOrigins([]string{"http://localhost:9000"})
	// methodsOk := handlers.AllowedMethods([]string{"GET", "HEAD", "POST", "PUT", "OPTIONS"})

	srv := &http.Server{
		// Handler:      handlers.CORS(originsOk, headersOk, methodsOk)(router),
		Handler:      router,
		Addr:         "127.0.0.1:" + port,
		WriteTimeout: 15 * time.Second,
		ReadTimeout:  15 * time.Second,
	}

	log.Fatal(srv.ListenAndServe())
}

func (h spaHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// get the absolute path to prevent directory traversal
	path, err := filepath.Abs(r.URL.Path)
	if err != nil {
		// if we failed to get the absolute path respond with a 400 bad request and stop
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// prepend the path with the path to the static directory
	path = filepath.Join(h.staticPath, path)

	// check whether a file exists at the given path
	_, err = os.Stat(path)
	if os.IsNotExist(err) {
		// file does not exist, serve index.html
		http.ServeFile(w, r, filepath.Join(h.staticPath, h.indexPath))
		return
	} else if err != nil {
		// if we got an error (that wasn't that the file doesn't exist) stating the
		// file, return a 500 internal server error and stop
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// otherwise, use http.FileServer to serve the static dir
	http.FileServer(http.Dir(h.staticPath)).ServeHTTP(w, r)
}

// getUser returns a user from session s, on error returns an empty user
func getUser(s *sessions.Session) SSOUser {
	val := s.Values["user"]
	var user = SSOUser{}
	user, ok := val.(SSOUser)
	if !ok {
		return SSOUser{Authenticated: false}
	}
	return user
}

func authRedirectHandler(w http.ResponseWriter, r *http.Request) {
	provider := "github"

	redirectUrl := fmt.Sprintf("http://%s/auth/callback", r.Host)

	providerSecrets := map[string]map[string]string{
		"github": {
			"clientID":     clientID,
			"clientSecret": clientSecret,
			"redirectURL":  redirectUrl,
		},
	}

	providerScopes := map[string][]string{
		"github": []string{"public_repo"},
	}

	providerData := providerSecrets[provider]
	actualScopes := providerScopes[provider]
	authURL, err := gocial.New().
		Driver(provider).
		Scopes(actualScopes).
		Redirect(
			providerData["clientID"],
			providerData["clientSecret"],
			providerData["redirectURL"],
		)

	// Check for errors (usually driver not valid)
	if err != nil {
		//c.Writer.Write([]byte("Error: " + err.Error()))
		fmt.Printf("Error %v", err)
		return
	}

	http.Redirect(w, r, authURL, http.StatusFound)
}

func authCallBackHandler(w http.ResponseWriter, r *http.Request) {
	// Retrieve query params for state and code
	vals := r.URL.Query()

	states, ok := vals["state"]
	var state string
	if ok {
		if len(states) >= 1 {
			state = states[0] // The first
		}
	}

	codes, ok := vals["code"]
	var code string
	if ok {
		if len(codes) >= 1 {
			code = codes[0] // The first
		}
	}

	// Handle callback and check for errors
	user, token, err := gocial.Handle(state, code)
	if err != nil {
		// c.Writer.Write([]byte("Error: " + err.Error()))
		fmt.Printf("Error %v", err)
		return
	}

	// Print in terminal user information
	fmt.Printf("%#v\n", token)
	fmt.Printf("%#v\n", user)

	session, err := store.Get(r, "spastore")
	if err != nil {
		// http.Error(w, err.Error(), http.StatusInternalServerError)
		http.Redirect(w, r, "/", http.StatusInternalServerError)
		return
	}

	userFromSession := getUser(session)
	if auth := userFromSession.Authenticated; !auth {
		fmt.Println("Previously user had no active session!")
	}

	ssouser := &SSOUser{
		Username:      user.Username,
		Authenticated: true,
	}

	session.Values["user"] = ssouser

	err = session.Save(r, w)
	if err != nil {
		// http.Error(w, err.Error(), http.StatusInternalServerError)
		http.Redirect(w, r, "/", http.StatusInternalServerError)
		return
	}

	// If no errors, show provider name
	// c.Writer.Write([]byte("Hi, " + user.FullName))
	http.Redirect(w, r, "/", http.StatusFound)
}

func authValidateHandler(w http.ResponseWriter, r *http.Request) {
	session, err := store.Get(r, "spastore")
	if err != nil {
		// http.Error(w, err.Error(), http.StatusInternalServerError)
		http.Redirect(w, r, "/", http.StatusInternalServerError)
		return
	}
	userFromSession := getUser(session)
	if auth := userFromSession.Authenticated; !auth {
		fmt.Println("Previously user had no active session!")
		w.Header().Set("Content-Type", "application/json")
		w.Write([]byte(`{ "authenticated": false }`))
		return
	}
	w.Header().Set("Content-Type", "application/json")
	w.Write([]byte(`{ "authenticated": true }`))
	return
}

// UNSURE IF NEEDED
// logout revokes authentication for a user
// func logout(w http.ResponseWriter, r *http.Request) {
// 	session, err := store.Get(r, "spastore")
// 	if err != nil {
// 		http.Error(w, err.Error(), http.StatusInternalServerError)
// 		return
// 	}
// 	session.Values["user"] = SSOUser{}
// 	session.Options.MaxAge = -1
// 	err = session.Save(r, w)
// 	if err != nil {
// 		http.Error(w, err.Error(), http.StatusInternalServerError)
// 		return
// 	}
// 	http.Redirect(w, r, "/", http.StatusFound)
// }
